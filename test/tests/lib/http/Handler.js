test.method ("http.Handler", "run")
    .should ("run the handler")
        .up (s => s.http.defineHandlerPlugin ("TestPlugin")
            .onPreRun ((handler, ctx) => ctx.pluginOnPreRunCalled = true)
            .onPostRun ((handler, ctx) => ctx.pluginOnPostRunCalled = true)
        )
        .up (s => s.class = s.http.defineHandler ("Controller")
            .handlerplugin ("http:test-plugin")
            .onRun (ctx => ctx.onRunCalled = true)
            .onPreRun (ctx => ctx.onPreRunCalled = true)
            .onPostRun (ctx => ctx.onPostRunCalled = true)
        )
        .givenContext ()
        .expectingPropertyToBe ("result.onRunCalled", true)
        .expectingPropertyToBe ("result.onPreRunCalled", true)
        .expectingPropertyToBe ("result.onPostRunCalled", true)
        .expectingPropertyToBe ("result.pluginOnPreRunCalled", true)
        .expectingPropertyToBe ("result.pluginOnPostRunCalled", true)
        .expectingPropertyToBeOfType ("result.parent", "http.Context")
        .commit ()

    .should ("process the request")
        .up (s => s.class = s.http.defineHandler ("Controller")
            .onRun (ctx => ctx.root.onRunCalled = true)
            .onCatch (ctx => ctx.root.onCatchCalled = true)
            .onFinally (ctx => ctx.root.onFinallyCalled = true)
        )
        .givenContext ()
        .expectingPropertyToBe ("args.0.onRunCalled", true)
        .expectingPropertyToBe ("args.0.onCatchCalled", undefined)
        .expectingPropertyToBe ("args.0.onFinallyCalled", true)
        .commit ()

    .should ("use the provided context if it's an instance of Handler.Context")
        .up (s => s.class = s.http.defineHandler ("Controller")
            .onRun (ctx => ctx.onRunCalled = true)
            .onCatch (ctx => ctx.onCatchCalled = true)
            .onFinally (ctx => ctx.onFinallyCalled = true)
        )
        .up (s => s.args = s.class.Context.new (s.Context.new ()))
        .expectingPropertyToBe ("args.0.onRunCalled", true)
        .expectingPropertyToBe ("args.0.onCatchCalled", undefined)
        .expectingPropertyToBe ("args.0.onFinallyCalled", true)
        .commit ()

    .should ("rethrow the error in onCatch by default")
        .up (s => s.class = s.http.defineHandler ("Controller")
            .onRun (() => { throw new Error ("ERR!"); })
            .onFinally (ctx => ctx.root.onFinallyCalled = true)
        )
        .givenContext ()
        .throws ("ERR!")
        .expectingPropertyToBe ("args.0.onFinallyCalled", true)
        .commit ()

    .should ("not rethrow the error in onCatch if ctx.error has been cleared")
        .up (s => s.class = s.http.defineHandler ("Controller")
            .onRun (() => { throw new Error ("ERR!"); })
            .onPreCatch (ctx => ctx.error = null)
            .onFinally (ctx => ctx.root.onFinallyCalled = true)
        )
        .givenContext ()
        .expectingPropertyToBe ("args.0.onFinallyCalled", true)
        .commit ()

    .should ("call finally when run throws")
        .up (s => s.class = s.http.defineHandler ("Controller")
            .onRun (() => { throw new Error ("ERR!"); })
            .onCatch (ctx => { ctx.root.onCatchCalled = true; ctx.error = null; })
            .onFinally (ctx => ctx.root.onFinallyCalled = true)
        )
        .givenContext ()
        .expectingPropertyToBe ("args.0.onCatchCalled", true)
        .expectingPropertyToBe ("args.0.onFinallyCalled", true)
        .commit ()

    .should ("update the error the the one throw during the catch phase")
        .up (s => s.class = s.http.defineHandler ("Controller")
            .onRun (() => { throw new Error ("ERR!"); })
            .onCatch (ctx => { throw new Error ("CATCH: " + ctx.error.message); })
        )
        .givenContext ()
        .throws ("CATCH: ERR!")
        .commit ()

    .should ("update the error the the one throw during the finally phase")
        .up (s => s.class = s.http.defineHandler ("Controller")
            .onRun (() => { throw new Error ("ERR!"); })
            .onCatch (ctx => { throw new Error ("CATCH: " + ctx.error.message); })
            .onFinally (ctx => { throw new Error ("FINALLY: " + ctx.error.message); })
        )
        .givenContext ()
        .throws ("FINALLY: CATCH: ERR!")
        .commit ()
;


test.method ("http.Handler", "endpoint", true)
    .should ("update the request method and path conditions")
        .up (s => s.class = s.class.defineSubclass ("test.handlers.Handler1"))
        .expectingPropertyToBe ("class.requestMethod", "GET")
        .expectingPropertyToBe ("class.requestPath", "/test/handler1")
        .commit ()

    .should ("pluralize the last path component when needed")
        .up (s => s.class = s.class.defineSubclass ("test.handlers.CreateJob"))
        .expectingPropertyToBe ("class.requestMethod", "POST")
        .expectingPropertyToBe ("class.requestPath", "/test/jobs")
        .commit ()
;


test.object ("http.Handler", false)
    .should ("add endpoint automatically when onRun () is defined but endpoint () was not called")
        .project ("myapp")
        .up (s => s.class = nit.lookupClass ("myapp.apis.AutoPath"))
        .expectingPropertyToBe ("class.requestMethod", "GET")
        .expectingPropertyToBe ("class.requestPath", "/myapp/auto-path")
        .commit ()
;


test.object ("http.Handler")
    .should ("add instance level endpoint if specified")
        .given ({ endpoint: "GET /users" })
        .expectingPropertyToBe ("instance.requestMethod", "GET")
        .expectingPropertyToBe ("instance.requestPath", "/users")
        .expectingPropertyToBe ("instance.conditions.length", 2)
        .expectingPropertyToBeOfType ("instance.conditions.0", "http.conditions.RequestMethod")
        .expectingPropertyToBeOfType ("instance.conditions.1", "http.conditions.RequestPath")
        .expectingMethodToReturnValue ("instance.applicableTo", { method: "GET", path: "/people" }, false)
        .expectingMethodToReturnValue ("instance.applicableTo", { method: "GET", path: "/users" }, true)
        .commit ()
;


test.method ("http.Handler", "applicableTo")
    .should ("return true if the context satisfy the specified conditions")
        .up (s => s.class = s.class.defineSubclass ("MyHandler")
            .endpoint ("GET /users")
        )
        .given ({ method: "GET", path: "/users" })
        .returns (true)
        .expectingPropertyToBe ("object.requestMethod", "")
        .expectingPropertyToBe ("class.conditions.length", 2)
        .commit ()

    .should ("return false if the context does not satisfy the specified conditions")
        .up (s => s.class = s.class.defineSubclass ("MyHandler")
            .endpoint ("POST", "/users")
        )
        .given ({ method: "POST", path: "/people" })
        .returns (false)
        .commit ()
;


test.method ("http.Handler", "endpoint", true)
    .should ("try to figure out the method by checking the handler's prefix")
        .up (s => s.class = s.class.defineSubclass ("CreateUser"))
        .expectingPropertyToBe ("class.requestMethod", "POST")
        .expectingPropertyToBe ("class.requestPath", "/users")
        .commit ()

    .reset ()
        .up (s => s.class = s.class.defineSubclass ("UpdateUser")
            .defineRequest (Request =>
                Request
                    .path ("id")
                    .form ("firstname")
            )
        )
        .expectingPropertyToBe ("class.requestMethod", "PUT")
        .expectingPropertyToBe ("class.requestPath", "/users/:id")
        .commit ()
;
